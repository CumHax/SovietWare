package me.cumhax.soviet.impl.module.exploit;

import me.cumhax.soviet.api.module.Category;
import me.cumhax.soviet.api.module.Module;
import net.minecraft.entity.Entity;
import net.minecraft.util.MovementInput;
import net.minecraft.world.chunk.EmptyChunk;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

public class EntitySpeed extends Module
{
    public EntitySpeed() 
	{	
        super("EntitySpeed", "", Category.EXPLOIT);
    }

	@SubscribeEvent
	public void onTick(TickEvent.ClientTickEvent event)
	{
		if (mc.player == null || mc.world == null) return;

		if (mc.player.getRidingEntity() != null)
		{
			Entity riding = mc.player.getRidingEntity();
			steerEntity(riding);
		}

	}

	private void steerEntity(Entity entity)
	{
		entity.motionY = -0.4D;

		moveForward(entity);

	}


	private void moveForward(Entity entity)
	{
		if (entity != null)
		{
			MovementInput movementInput = mc.player.movementInput;

			double forward = movementInput.moveForward;
			double strafe = movementInput.moveStrafe;
			boolean movingForward = forward != 0;
			boolean movingStrafe = strafe != 0;
			float yaw = mc.player.rotationYaw;

			if (!movingForward && !movingStrafe)
			{
				setEntitySpeed(entity, 0, 0);
			}
			else
			{
				if (forward != 0.0D)
				{
					if (strafe > 0.0D)
					{
						yaw += (forward > 0.0D ? -45 : 45);
					}
					else if (strafe < 0.0D)
					{
						yaw += (forward > 0.0D ? 45 : -45);
					}
					strafe = 0.0D;
					if (forward > 0.0D)
					{
						forward = 1.0D;
					}
					else
					{
						forward = -1.0D;
					}
				}

				double cos = Math.cos(Math.toRadians(yaw + 90.0F));
				double sin = Math.sin(Math.toRadians(yaw + 90.0F));

				double motX = (forward * 3.8 * cos + strafe * 3.8 * sin);
				double motZ = (forward * 3.8 * sin - strafe * 3.8 * cos);

				if (isBorderingChunk(entity, motX, motZ))
				{
					motX = motZ = 0;
				}

				setEntitySpeed(entity, motX, motZ);
			}
		}
	}

	private void setEntitySpeed(Entity entity, double motX, double motZ)
	{
		entity.motionX = motX;
		entity.motionZ = motZ;
	}

	private boolean isBorderingChunk(Entity entity, double motX, double motZ)
	{
		return mc.world.getChunk((int) (entity.posX + motX) >> 4, (int) (entity.posZ + motZ) >> 4) instanceof EmptyChunk;
	}

}
